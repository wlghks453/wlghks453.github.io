---
layout: default
title: 카프카
description: "카프카 메인 메뉴"
has_children: true
nav_order: 2
---

## 목차
{: .no_toc .text-delta }

1. TOC
{:toc}

---

# 🚀 카프카

## 1. **카프카의 탄생 배경**
LinkedIn은 내부 시스템의 **데이터 파이프라인 문제**를 해결하기 위해 **카프카**를 개발했습니다. 기존 시스템에서는 **실시간 데이터 처리의 어려움, 확장성 부족, 장애 시 데이터 손실** 등의 문제가 있었습니다. 이를 해결하기 위해 **카프카**가 설계되었습니다.

### **카프카의 설계 목표**
- **실시간 데이터 처리**: 대용량 데이터를 **빠르고 신뢰성 있게 전송**할 수 있는 **스트리밍 플랫폼**.
- **확장성**: **분산 시스템 아키텍처**로, 데이터 양이 증가해도 쉽게 **확장**할 수 있습니다.
- **내결함성**: 서버 장애 발생 시에도 **데이터 손실 없이 복구 및 재시도**가 가능합니다.
- **유연성**: **프로듀서-컨슈머 모델**을 사용해 다양한 애플리케이션에서 데이터를 쉽게 주고받을 수 있습니다.

---

## 2. **카프카의 주요 개념과 성능 최적화**

카프카는 **이벤트 스트리밍 플랫폼**으로, 소프트웨어에서 발생하는 **모든 유형의 사건이나 작업**(이벤트)을 메시지 형태로 처리합니다. 이를 통해 **고성능 데이터 처리**를 제공합니다.

### **성능 최적화를 위한 페이지 캐시 활용**
- **JVM 위에서 동작하는 카프카 브로커**는 **페이지 캐시**를 활용해 **디스크 입출력(I/O) 속도**를 극대화합니다.
- **페이지 캐시(Page Cache)** 란, 운영체제(OS)에서 **파일 입출력 성능을 높이기 위해 사용하는 메모리 영역**입니다.
- 한 번 읽은 데이터는 **페이지 캐시에 저장**되며, 다음 접근 시 **디스크가 아닌 메모리에서 직접 읽습니다**.

### **페이지 캐시 미사용 시 문제점**
- **지속적으로 변경되는 데이터**로 인해 **가비지 컬렉션(GC)** 이 빈번하게 발생할 수 있습니다.
- GC가 자주 발생하면 **브로커 성능이 크게 저하**됩니다.

### **힙 메모리 최적화와 고성능 유지**
- **페이지 캐시 덕분에 브로커는 힙 메모리를 크게 할당할 필요가 없습니다**.
- 이는 **메모리 사용 효율성**을 높이고 **오버헤드**를 줄여줍니다.
- 결과적으로 **카프카 브로커는 고성능을 유지**하며, 데이터 처리 속도를 극대화할 수 있습니다.
