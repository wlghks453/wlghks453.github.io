---
layout: default
title: 컨슈머
parent: 카프카
nav_order: 3
---

{: .no_toc }

{: .no_toc .text-delta }

1. TOC
   {:toc}

---

# 📥 카프카 컨슈머

- **컨슈머(Consumer)**는 **카프카 토픽**에서 데이터를 가져와 처리하는 역할을 담당합니다.
- **컨슈머 그룹**을 통해 여러 컨슈머가 협력하며, 데이터를 **분산 처리**할 수 있습니다.
- 각 컨슈머는 **오프셋**을 사용해 데이터의 **읽기 위치를 추적**하며, 수동 또는 자동으로 커밋할 수 있습니다.

## **컨슈머 그룹**

- 여러 컨슈머들을 **하나의 그룹**으로 묶어 운영합니다.
- **한 파티션**은 **최대 한 컨슈머**에만 할당되지만, **한 컨슈머**는 **여러 파티션**을 처리할 수 있습니다.

```text
조건: 파티션 수 >= 컨슈머 수  
만약 컨슈머가 파티션 수보다 많으면 **할당되지 않은 컨슈머**는 유휴 상태가 됩니다.
```

- **컨슈머 그룹 간**에는 서로 영향을 미치지 않으며, 독립적으로 데이터 처리와 구독이 가능합니다.



## **리밸런싱(Rebalancing)**

- **리밸런싱**은 컨슈머 그룹 내 **컨슈머 추가 또는 장애**가 발생할 때 이루어집니다.
    - **컨슈머 추가** 시: 새로 추가된 컨슈머에게 파티션이 할당됩니다.
    - **컨슈머 장애** 시: 기존의 파티션들이 **정상 컨슈머로 재할당**됩니다.

- **리밸런싱 중**에는 **데이터를 읽을 수 없습니다**.

---

## **오프셋 커밋(Offset Commit)**

- 오프셋 커밋은 **데이터 처리 위치를 저장**하여 이후 데이터를 중복 처리하지 않도록 보장합니다.
- **명시적(수동)**과 **비명시적(자동)** 커밋 방식이 있습니다.
    - **중복 또는 유실을 방지**해야 하는 경우 **자동 커밋을 사용하지 않는 것이 좋습니다**.
    
## **poll() 메서드 동작 원리**

- **poll() 메서드**는 호출 시 클러스터에서 데이터를 직접 가져오지 않습니다.
- 대신, 컨슈머 내부에 **Fetcher 인스턴스**가 데이터를 미리 **내부 큐**에 가져옵니다.
- **poll()** 호출 시 **큐의 레코드**를 반환하여 데이터를 처리합니다.
- 🚗자세한 동작방식은 추후 작성예정

---

## **컨슈머 옵션**

### **auto.offset.reset**
- **오프셋이 없을 때** 어디서부터 데이터를 읽을지 선택하는 옵션입니다.
- **옵션 종류**:
    - **latest**(기본값): 가장 **최근 오프셋**부터 읽기.
    - **earliest**: 가장 **오래된 오프셋**부터 읽기.
    - **none**: 오프셋이 없으면 **에러 발생**.

### **enable.auto.commit**
- **자동 커밋**을 설정하는 옵션입니다. (기본값: `true`)
- **자동 커밋 간격**은 `auto.commit.interval.ms`로 지정합니다.

### **session.timeout.ms**
- **컨슈머와 브로커 연결**이 끊기기까지의 최대 시간을 설정합니다. (기본값: 10초)
- 이 시간 동안 **하트비트 전송**이 없으면 **리밸런싱**이 발생합니다.

### **heartbeat.interval.ms**
- **하트비트 전송 간격**을 설정합니다. (기본값: 3초)

---

## **리밸런스 리스너**

- **리밸런스 발생 감지**를 위한 인터페이스를 제공합니다.
    - **리밸런스 시작 시 호출되는 메서드**
    - **리밸런스 종료 후 호출되는 메서드**
- 마지막으로 처리한 레코드를 기준으로 커밋을 하기 위해서는 리밸런스가 시작하기 직전에 호출되는 메서드를 사용해야 합니다.

- **수동 커밋** 환경에서 리밸런스 리스너를 활용할 수 있다.
    - 자동 커밋 환경에서는 적용이 제한적입니다.

