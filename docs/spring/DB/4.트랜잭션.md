---
layout: default
title: 트랜잭션
parent: SPRING DB
grand_parent: 스프링
nav_order: 4
---

{: .no_toc }

{: .no_toc .text-delta }

1. TOC
{:toc}

---

# 💀트랜잭션 - 개념 이해

**데이터베이스**는 **트랜잭션(Transaction)** 이라는 개념을 지원하여 데이터를 안전하게 관리할 수 있습니다. **트랜잭션**은 데이터베이스에서 **하나의 작업(거래)을 안전하게 처리하는 것을 보장**하는 기능입니다.

## 1. 트랜잭션이 필요한 이유

트랜잭션은 **여러 작업을 하나의 작업처럼 처리**하는 기능입니다. 예를 들어, A의 계좌에서 5000원을 B에게 이체할 때, 두 가지 작업이 하나의 트랜잭션으로 처리되어야 합니다.

**1000원 계좌이체 과정**:
1. A의 잔고에서 1000원 감소
2. B의 잔고에서 1000원 증가

만약 1번 작업만 성공하고 2번 작업에서 문제가 발생하면, A의 잔고만 줄어드는 심각한 오류가 발생할 수 있습니다. 하지만 **트랜잭션**을 사용하면, 모든 작업이 **성공해야만** 데이터베이스에 저장(커밋)되고, 하나라도 실패하면 **이전 상태로 되돌아가는(롤백)** 기능을 제공합니다.

- **Commit**: 모든 작업이 성공해서 정상 반영되는 것.
- **Rollback**: 하나라도 실패했을 때, 작업 이전 상태로 되돌리는 것.

## 2. 트랜잭션의 ACID 속성

트랜잭션은 **ACID**라는 4가지 속성을 보장해야 합니다.

- **원자성(Atomicity)**: 트랜잭션 내의 모든 작업은 **하나의 작업처럼 모두 성공하거나 모두 실패**해야 합니다.
- **일관성(Consistency)**: 트랜잭션은 **데이터베이스의 일관성**을 유지해야 합니다. 예를 들어, 무결성 제약 조건을 항상 만족해야 합니다.
- **격리성(Isolation)**: 동시에 실행되는 트랜잭션들이 서로 **영향을 미치지 않도록** 격리해야 합니다. 이를 통해 데이터의 충돌을 방지합니다.
- **지속성(Durability)**: 트랜잭션이 성공적으로 끝나면 **결과는 영구적으로 저장**되어야 합니다. 시스템 장애가 발생해도 성공한 트랜잭션의 결과는 보존되어야 합니다.

## 3. 트랜잭션 격리 수준 (Isolation Level)

트랜잭션 간의 **격리성**을 보장하기 위해, **트랜잭션 격리 수준**이 존재합니다. 격리성을 완벽히 보장하면 동시 처리 성능이 떨어지므로, **격리 수준**에 따라 성능과 안전성 사이의 균형을 선택할 수 있습니다.

### 트랜잭션 격리 수준

1. **READ UNCOMMITTED**: **커밋되지 않은 데이터**도 읽을 수 있습니다. 성능은 높지만 데이터 무결성 문제가 발생할 수 있습니다.
2. **READ COMMITTED**: **커밋된 데이터**만 읽을 수 있습니다. 대부분의 DBMS에서 기본으로 사용하는 수준입니다.
3. **REPEATABLE READ**: 트랜잭션이 시작된 이후부터 **반복적으로 읽어도 같은 결과**를 보장합니다. (MySQL 기본 격리 수준)
4. **SERIALIZABLE**: 트랜잭션을 **직렬화**하여 처리합니다. 가장 높은 격리 수준이지만, 성능이 떨어질 수 있습니다.

# 👦데이터베이스 연결 구조와 DB 세션

**DB 세션**은 트랜잭션을 이해하는 데 중요한 개념입니다. 애플리케이션이 데이터베이스에 연결할 때, **세션(Session)** 을 통해 트랜잭션이 관리되고 SQL이 실행됩니다.

## 1. 데이터베이스 연결 구조

사용자는 웹 애플리케이션 서버(WAS)나 DB 접근 툴 같은 클라이언트를 통해 데이터베이스 서버에 접근합니다. 이때, 클라이언트가 **데이터베이스 서버에 연결을 요청**하면, **데이터베이스 서버는 세션(Session)을 생성**합니다.

- **세션**은 하나의 커넥션과 연결되며, 이 커넥션을 통해 수행되는 모든 SQL 요청은 이 세션에서 처리됩니다.
- 개발자가 클라이언트를 통해 SQL을 전달하면, **현재 연결된 세션이 SQL을 실행**합니다.
- **세션은 트랜잭션을 시작**하고, 작업이 완료되면 **커밋(Commit)** 또는 **롤백(Rollback)** 을 통해 트랜잭션을 종료합니다.

## 2. 세션의 관리

- **세션은 커넥션을 통해 관리**됩니다. 사용자가 커넥션을 닫거나, 데이터베이스 관리자가(DBA) 세션을 강제로 종료하면 해당 세션도 종료됩니다.
- 트랜잭션이 종료되면 세션은 새로운 트랜잭션을 시작할 수 있으며, **커넥션이 유지되는 한 동일한 세션이 계속해서 사용**됩니다.

## 3. 커넥션 풀과 세션

**커넥션 풀**을 사용하면 미리 일정 수의 커넥션을 생성해 놓고 필요할 때마다 재사용합니다. 예를 들어, **커넥션 풀이 10개의 커넥션을 생성**하면, 이 커넥션과 대응되는 **10개의 세션도 생성**됩니다.

### 간단한 구조

- **커넥션 = 세션**: 하나의 커넥션이 하나의 세션과 연결되며, 세션을 통해 SQL이 실행되고 트랜잭션이 관리됩니다.
- **커넥션 풀 사용 시**: 커넥션 풀에서 제공하는 커넥션 개수만큼 세션도 생성되고 관리됩니다.

## 4. 정리

DB 세션은 **데이터베이스와 클라이언트 간의 연결을 유지**하고, **트랜잭션을 관리**하는 중요한 개념입니다. 커넥션과 세션은 1:1로 대응하며, 커넥션이 닫힐 때 세션도 종료됩니다. 또한 **커넥션 풀**을 사용할 때는 커넥션과 세션이 동시에 관리됩니다.

# 🙋‍♂️자동 커밋과 수동 커밋

데이터베이스에서 트랜잭션을 제어하는 두 가지 방식인 **자동 커밋(Autocommit)** 과 **수동 커밋(Manual Commit)** 에 대해 알아보겠습니다. 자동 커밋은 각 쿼리가 실행된 직후에 자동으로 커밋을 하는 방식이고, 수동 커밋은 트랜잭션이 끝나면 개발자가 **명시적으로 커밋 또는 롤백**하는 방식입니다.

## 1. 자동 커밋 모드

자동 커밋 모드는 **각 SQL 쿼리가 실행될 때마다** 자동으로 트랜잭션을 커밋합니다. 이 방식은 간편하지만, 트랜잭션의 원자성을 제대로 보장하지 못할 수 있습니다.

### 자동 커밋 예시

```sql
set autocommit true; -- 자동 커밋 모드 설정
insert into fruits(fruit_name, quantity) values ('apple', 100); -- 자동 커밋
insert into fruits(fruit_name, quantity) values ('banana', 150); -- 자동 커밋
```

- **자동 커밋 모드**: 각 `insert`문이 실행될 때마다 커밋이 자동으로 이루어집니다. 쿼리를 실행할 때마다 트랜잭션이 끝나므로, 트랜잭션 단위로 묶기 어렵습니다.
- **문제점**: 여러 쿼리를 하나의 트랜잭션으로 묶을 수 없기 때문에, 중간에 오류가 발생하더라도 이미 커밋된 데이터는 롤백할 수 없습니다.

## 2. 수동 커밋 모드 (트랜잭션)

트랜잭션을 직접 관리하려면 **자동 커밋을 끄고 수동 커밋 모드**로 전환해야 합니다. 이 모드에서는 **여러 쿼리를 하나의 트랜잭션 안에서 처리**하고, 트랜잭션 종료 시 `commit` 또는 `rollback`을 명시적으로 호출해야 합니다.

### 수동 커밋 예시

```sql
set autocommit false; -- 수동 커밋 모드 설정 (트랜잭션 시작)
insert into bank_accounts(account_name, balance) values ('Alice', 50000);
insert into bank_accounts(account_name, balance) values ('Bob', 70000);
-- 여기까지는 커밋되지 않음

commit; -- 트랜잭션 커밋하여 모든 변경 사항을 저장
```

- **수동 커밋 모드**: 여러 쿼리를 하나의 트랜잭션으로 처리한 뒤, 최종적으로 **`commit`**을 호출하여 모든 작업을 저장합니다. 만약 중간에 문제가 발생하면, 트랜잭션 내의 모든 변경 사항을 **`rollback`**할 수 있습니다.

### 수동 커밋 모드에서 롤백

```sql
set autocommit false; -- 수동 커밋 모드 설정
insert into bank_accounts(account_name, balance) values ('Alice', 50000);
insert into bank_accounts(account_name, balance) values ('Bob', 70000);

rollback; -- 오류 발생 시 트랜잭션을 롤백하여 변경 사항 취소
```

- **롤백**: 트랜잭션 중간에 오류가 발생하면, **`rollback`**을 사용하여 트랜잭션을 취소하고 모든 변경을 되돌립니다.

## 3. 수동 커밋 모드에서 일정 시간 커밋/롤백이 없을 때의 문제

수동 커밋 모드에서는 트랜잭션이 커밋 또는 롤백으로 종료될 때까지 유지됩니다. 그러나 트랜잭션이 너무 오래 유지되면 **다음과 같은 문제가 발생**할 수 있습니다:

1. **락(Lock) 문제**: 트랜잭션이 열려 있는 동안 해당 데이터에 **락**이 걸릴수도 있습니다. 이로 인해 다른 트랜잭션이 해당 데이터에 접근할 수 없게 되고, 시스템 성능이 저하될 수 있습니다.
2. **리소스 사용 증가**: 트랜잭션이 오래 유지되면, 데이터베이스는 해당 트랜잭션에 대한 **리소스를 지속적으로 관리**해야 하므로 불필요한 리소스가 낭비될 수 있습니다.
3. **타임아웃**: 대부분의 데이터베이스는 **트랜잭션 타임아웃** 설정을 지원합니다. 일정 시간이 지나도 트랜잭션이 완료되지 않으면, 데이터베이스는 자동으로 **트랜잭션을 롤백**할 수 있습니다.

### 해결책

- 수동 커밋 모드에서는 작업이 끝난 후 즉시 **`commit`** 또는 **`rollback`**을 호출하여 **트랜잭션을 종료**하는 것이 중요합니다.
- 트랜잭션이 오랫동안 유지되지 않도록 주기적으로 트랜잭션을 종료하고, **타임아웃 설정**을 통해 트랜잭션이 적절히 관리되도록 해야 합니다.

## 4. 정리

- **자동 커밋 모드**: 각 쿼리 실행 후 자동으로 커밋되어 편리하지만, 트랜잭션 단위로 작업을 묶는 데 어려움이 있습니다.
- **수동 커밋 모드**: 트랜잭션을 명시적으로 제어할 수 있어 원자성과 데이터 일관성을 유지할 수 있습니다. 커밋 또는 롤백이 일정 시간 내에 발생하지 않으면, **락 문제**와 **타임아웃** 등의 문제가 생길 수 있습니다.
