---
layout: default
title: 트랜잭션
parent: SPRING DB
grand_parent: 스프링
nav_order: 4
---

{: .no_toc }

{: .no_toc .text-delta }

1. TOC
{:toc}

---

# 💀트랜잭션 - 개념 이해

**데이터베이스**는 **트랜잭션(Transaction)** 이라는 개념을 지원하여 데이터를 안전하게 관리할 수 있습니다. **트랜잭션**은 데이터베이스에서 **하나의 작업(거래)을 안전하게 처리하는 것을 보장**하는 기능입니다.

## 1. 트랜잭션이 필요한 이유

트랜잭션은 **여러 작업을 하나의 작업처럼 처리**하는 기능입니다. 예를 들어, A의 계좌에서 5000원을 B에게 이체할 때, 두 가지 작업이 하나의 트랜잭션으로 처리되어야 합니다.

**1000원 계좌이체 과정**:
1. A의 잔고에서 1000원 감소
2. B의 잔고에서 1000원 증가

만약 1번 작업만 성공하고 2번 작업에서 문제가 발생하면, A의 잔고만 줄어드는 심각한 오류가 발생할 수 있습니다. 하지만 **트랜잭션**을 사용하면, 모든 작업이 **성공해야만** 데이터베이스에 저장(커밋)되고, 하나라도 실패하면 **이전 상태로 되돌아가는(롤백)** 기능을 제공합니다.

- **Commit**: 모든 작업이 성공해서 정상 반영되는 것.
- **Rollback**: 하나라도 실패했을 때, 작업 이전 상태로 되돌리는 것.

## 2. 트랜잭션의 ACID 속성

트랜잭션은 **ACID**라는 4가지 속성을 보장해야 합니다.

- **원자성(Atomicity)**: 트랜잭션 내의 모든 작업은 **하나의 작업처럼 모두 성공하거나 모두 실패**해야 합니다.
- **일관성(Consistency)**: 트랜잭션은 **데이터베이스의 일관성**을 유지해야 합니다. 예를 들어, 무결성 제약 조건을 항상 만족해야 합니다.
- **격리성(Isolation)**: 동시에 실행되는 트랜잭션들이 서로 **영향을 미치지 않도록** 격리해야 합니다. 이를 통해 데이터의 충돌을 방지합니다.
- **지속성(Durability)**: 트랜잭션이 성공적으로 끝나면 **결과는 영구적으로 저장**되어야 합니다. 시스템 장애가 발생해도 성공한 트랜잭션의 결과는 보존되어야 합니다.

## 3. 트랜잭션 격리 수준 (Isolation Level)

트랜잭션 간의 **격리성**을 보장하기 위해, **트랜잭션 격리 수준**이 존재합니다. 격리성을 완벽히 보장하면 동시 처리 성능이 떨어지므로, **격리 수준**에 따라 성능과 안전성 사이의 균형을 선택할 수 있습니다.

### 트랜잭션 격리 수준

1. **READ UNCOMMITTED**: **커밋되지 않은 데이터**도 읽을 수 있습니다. 성능은 높지만 데이터 무결성 문제가 발생할 수 있습니다.
2. **READ COMMITTED**: **커밋된 데이터**만 읽을 수 있습니다. 대부분의 DBMS에서 기본으로 사용하는 수준입니다.
3. **REPEATABLE READ**: 트랜잭션이 시작된 이후부터 **반복적으로 읽어도 같은 결과**를 보장합니다. (MySQL 기본 격리 수준)
4. **SERIALIZABLE**: 트랜잭션을 **직렬화**하여 처리합니다. 가장 높은 격리 수준이지만, 성능이 떨어질 수 있습니다.

# 👦데이터베이스 연결 구조와 DB 세션

**DB 세션**은 트랜잭션을 이해하는 데 중요한 개념입니다. 애플리케이션이 데이터베이스에 연결할 때, **세션(Session)** 을 통해 트랜잭션이 관리되고 SQL이 실행됩니다.

## 1. 데이터베이스 연결 구조

사용자는 웹 애플리케이션 서버(WAS)나 DB 접근 툴 같은 클라이언트를 통해 데이터베이스 서버에 접근합니다. 이때, 클라이언트가 **데이터베이스 서버에 연결을 요청**하면, **데이터베이스 서버는 세션(Session)을 생성**합니다.

- **세션**은 하나의 커넥션과 연결되며, 이 커넥션을 통해 수행되는 모든 SQL 요청은 이 세션에서 처리됩니다.
- 개발자가 클라이언트를 통해 SQL을 전달하면, **현재 연결된 세션이 SQL을 실행**합니다.
- **세션은 트랜잭션을 시작**하고, 작업이 완료되면 **커밋(Commit)** 또는 **롤백(Rollback)** 을 통해 트랜잭션을 종료합니다.

## 2. 세션의 관리

- **세션은 커넥션을 통해 관리**됩니다. 사용자가 커넥션을 닫거나, 데이터베이스 관리자가(DBA) 세션을 강제로 종료하면 해당 세션도 종료됩니다.
- 트랜잭션이 종료되면 세션은 새로운 트랜잭션을 시작할 수 있으며, **커넥션이 유지되는 한 동일한 세션이 계속해서 사용**됩니다.

## 3. 커넥션 풀과 세션

**커넥션 풀**을 사용하면 미리 일정 수의 커넥션을 생성해 놓고 필요할 때마다 재사용합니다. 예를 들어, **커넥션 풀이 10개의 커넥션을 생성**하면, 이 커넥션과 대응되는 **10개의 세션도 생성**됩니다.

### 간단한 구조

- **커넥션 = 세션**: 하나의 커넥션이 하나의 세션과 연결되며, 세션을 통해 SQL이 실행되고 트랜잭션이 관리됩니다.
- **커넥션 풀 사용 시**: 커넥션 풀에서 제공하는 커넥션 개수만큼 세션도 생성되고 관리됩니다.

## 4. 정리

DB 세션은 **데이터베이스와 클라이언트 간의 연결을 유지**하고, **트랜잭션을 관리**하는 중요한 개념입니다. 커넥션과 세션은 1:1로 대응하며, 커넥션이 닫힐 때 세션도 종료됩니다. 또한 **커넥션 풀**을 사용할 때는 커넥션과 세션이 동시에 관리됩니다.

{: .note }
> **`트랜잭션 적용`** 똑같은 커넥션을 사용해야 트랜잭션을 적용할 수 있습니다.

> 커넥션이 다르면 다른 세션이기 때문에 트랜잭션 단위로 묶을 수 없습니다.



# 🙋‍♂️자동 커밋과 수동 커밋

데이터베이스에서 트랜잭션을 제어하는 두 가지 방식인 **자동 커밋(Autocommit)** 과 **수동 커밋(Manual Commit)** 에 대해 알아보겠습니다. 자동 커밋은 각 쿼리가 실행된 직후에 자동으로 커밋을 하는 방식이고, 수동 커밋은 트랜잭션이 끝나면 개발자가 **명시적으로 커밋 또는 롤백**하는 방식입니다.

## 1. 자동 커밋 모드

자동 커밋 모드는 **각 SQL 쿼리가 실행될 때마다** 자동으로 트랜잭션을 커밋합니다. 이 방식은 간편하지만, 트랜잭션의 원자성을 제대로 보장하지 못할 수 있습니다.

### 자동 커밋 예시

```sql
set autocommit true; -- 자동 커밋 모드 설정
insert into fruits(fruit_name, quantity) values ('apple', 100); -- 자동 커밋
insert into fruits(fruit_name, quantity) values ('banana', 150); -- 자동 커밋
```

- **자동 커밋 모드**: 각 `insert`문이 실행될 때마다 커밋이 자동으로 이루어집니다. 쿼리를 실행할 때마다 트랜잭션이 끝나므로, 트랜잭션 단위로 묶기 어렵습니다.
- **문제점**: 여러 쿼리를 하나의 트랜잭션으로 묶을 수 없기 때문에, 중간에 오류가 발생하더라도 이미 커밋된 데이터는 롤백할 수 없습니다.

## 2. 수동 커밋 모드 (트랜잭션)

트랜잭션을 직접 관리하려면 **자동 커밋을 끄고 수동 커밋 모드**로 전환해야 합니다. 이 모드에서는 **여러 쿼리를 하나의 트랜잭션 안에서 처리**하고, 트랜잭션 종료 시 `commit` 또는 `rollback`을 명시적으로 호출해야 합니다.

### 수동 커밋 예시

```sql
set autocommit false; -- 수동 커밋 모드 설정 (트랜잭션 시작)
insert into bank_accounts(account_name, balance) values ('Alice', 50000);
insert into bank_accounts(account_name, balance) values ('Bob', 70000);
-- 여기까지는 커밋되지 않음

commit; -- 트랜잭션 커밋하여 모든 변경 사항을 저장
```

- **수동 커밋 모드**: 여러 쿼리를 하나의 트랜잭션으로 처리한 뒤, 최종적으로 **`commit`**을 호출하여 모든 작업을 저장합니다. 만약 중간에 문제가 발생하면, 트랜잭션 내의 모든 변경 사항을 **`rollback`**할 수 있습니다.

### 수동 커밋 모드에서 롤백

```sql
set autocommit false; -- 수동 커밋 모드 설정
insert into bank_accounts(account_name, balance) values ('Alice', 50000);
insert into bank_accounts(account_name, balance) values ('Bob', 70000);

rollback; -- 오류 발생 시 트랜잭션을 롤백하여 변경 사항 취소
```

- **롤백**: 트랜잭션 중간에 오류가 발생하면, **`rollback`**을 사용하여 트랜잭션을 취소하고 모든 변경을 되돌립니다.

## 3. 수동 커밋 모드에서 일정 시간 커밋/롤백이 없을 때의 문제

수동 커밋 모드에서는 트랜잭션이 커밋 또는 롤백으로 종료될 때까지 유지됩니다. 그러나 트랜잭션이 너무 오래 유지되면 **다음과 같은 문제가 발생**할 수 있습니다:

1. **락(Lock) 문제**: 트랜잭션이 열려 있는 동안 해당 데이터에 **락**이 걸릴수도 있습니다. 이로 인해 다른 트랜잭션이 해당 데이터에 접근할 수 없게 되고, 시스템 성능이 저하될 수 있습니다.
2. **리소스 사용 증가**: 트랜잭션이 오래 유지되면, 데이터베이스는 해당 트랜잭션에 대한 **리소스를 지속적으로 관리**해야 하므로 불필요한 리소스가 낭비될 수 있습니다.
3. **타임아웃**: 대부분의 데이터베이스는 **트랜잭션 타임아웃** 설정을 지원합니다. 일정 시간이 지나도 트랜잭션이 완료되지 않으면, 데이터베이스는 자동으로 **트랜잭션을 롤백**할 수 있습니다.

### 해결책

- 수동 커밋 모드에서는 작업이 끝난 후 즉시 **`commit`** 또는 **`rollback`**을 호출하여 **트랜잭션을 종료**하는 것이 중요합니다.
- 트랜잭션이 오랫동안 유지되지 않도록 주기적으로 트랜잭션을 종료하고, **타임아웃 설정**을 통해 트랜잭션이 적절히 관리되도록 해야 합니다.

## 4. 정리

- **자동 커밋 모드**: 각 쿼리 실행 후 자동으로 커밋되어 편리하지만, 트랜잭션 단위로 작업을 묶는 데 어려움이 있습니다.
- **수동 커밋 모드**: 트랜잭션을 명시적으로 제어할 수 있어 원자성과 데이터 일관성을 유지할 수 있습니다. 커밋 또는 롤백이 일정 시간 내에 발생하지 않으면, **락 문제**와 **타임아웃** 등의 문제가 생길 수 있습니다.

# 🚲DB 락(Lock) - 수정

데이터베이스에서 여러 트랜잭션이 동시에 동일한 데이터를 수정하려고 하면 **데이터 무결성** 문제가 발생할 수 있습니다. 이를 해결하기 위해 **DB 락(Lock)** 개념이 사용됩니다. **락**은 트랜잭션이 데이터를 수정하는 동안 다른 트랜잭션이 해당 데이터에 접근하지 못하게 막아줍니다.

## 1. 락의 필요성

트랜잭션에서 데이터의 **일관성**과 **원자성**을 보장하기 위해 락이 필요합니다. 예를 들어, **세션1**이 **memberA**의 금액을 500으로 수정 중일 때, **세션2**가 동시에 **memberA**의 금액을 1000으로 수정하려고 하면 충돌이 발생할 수 있습니다. 이를 방지하기 위해 **세션1**이 락을 걸고, 트랜잭션이 완료될 때까지 **세션2**는 대기하게 됩니다.

## 2. DB 락 동작 예시

### 락 동작 과정


| **단계** | **세션1**                         | **세션2**                       | **DB 상태**                        |
|----------|------------------------------------|----------------------------------|------------------------------------|
| 1        | 트랜잭션 시작                      |                                  |                                  |
| 2        | memberA 금액 500 수정 시도         |                                  | 락 획득 (세션1)                    |
| 3        | update SQL 실행 (금액 500)         |                                  |                                  |
| 4        |                                    | 트랜잭션 시작                    |                                  |
| 5        |                                    | memberA 금액 1000 수정 시도      | 락 대기 (세션1이 락 보유 중)        |
| 6        | 커밋 수행, 락 반납                 |                                  | 락 반납                           |
| 7        |                                    | 락 획득                          | 세션2가 락 획득                    |
| 8        |                                    | update SQL 실행 (금액 1000)      |                                  |
| 9        |                                    | 커밋 수행, 락 반납               | 락 반납                           |


### 상세 설명

1. **세션1**이 트랜잭션을 시작하고 **memberA**의 금액을 500으로 수정하려고 시도합니다. 이때, **락**을 먼저 획득합니다.
2. **세션1**이 락을 획득한 후 **update SQL**을 실행하여 금액을 수정합니다.
3. **세션2**가 트랜잭션을 시작하고 **memberA**의 금액을 수정하려고 시도하지만, **세션1**이 이미 락을 보유 중이므로 **세션2**는 락이 반납될 때까지 대기합니다.
4. **세션1**이 커밋을 수행하고 락을 반납합니다.
5. **세션2**는 락을 획득하고 **memberA**의 금액을 1000으로 수정합니다.
6. **세션2**가 커밋을 수행하고, 트랜잭션을 종료하며 락을 반납합니다.

## 3. 락 대기와 타임아웃

- **세션2**는 락을 대기하는 동안 일정 시간이 지나면 **락 타임아웃** 오류가 발생할 수 있습니다. 이 대기 시간은 데이터베이스 설정에 따라 조정할 수 있습니다.
- **타임아웃**은 시스템에서 무한 대기를 방지하기 위한 보호 장치로, 성능과 안전성을 보장하는 데 중요합니다.

# 🌎DB 락(Lock) - 조회

일반적으로 **데이터 조회**는 락을 사용하지 않습니다. 대부분의 데이터베이스에서 데이터를 조회할 때는 **락을 획득하지 않고** 데이터를 바로 조회할 수 있습니다. 예를 들어, **세션1**이 데이터를 수정 중일 때, **세션2**는 데이터를 조회할 수 있지만, 데이터를 변경하려면 락이 필요하여 대기해야 합니다.

## 조회 시 락을 사용하는 경우

특정 상황에서는 **조회 시점**에도 **락**을 획득하고 싶을 때가 있습니다. 이런 경우에는 **`SELECT FOR UPDATE`** 구문을 사용하여 데이터를 조회하면서 **락을 획득**할 수 있습니다. 이 경우, 조회된 데이터는 다른 트랜잭션에서 수정할 수 없으며, **트랜잭션이 종료**될 때까지 락을 유지합니다.

### 조회 시 락이 필요한 상황

조회한 데이터를 기반으로 중요한 **계산**을 해야 할 때, 다른 트랜잭션에서 해당 데이터를 수정하지 못하도록 막아야 할 경우 **조회 시점에 락**을 사용합니다. 예를 들어, **memberA**의 금액을 조회하고 이를 바탕으로 애플리케이션에서 중요한 작업을 수행할 때, **조회 후 트랜잭션이 끝날 때까지 금액이 변경되지 않도록** 할 수 있습니다.

```sql
-- 세션1에서 데이터 수정 시도
set autocommit false;
select * from member where member_id='memberA' for update;
```

- **`SELECT FOR UPDATE`** 구문을 통해 조회와 동시에 **락**을 획득합니다.
- 트랜잭션이 종료될 때까지 **memberA**의 행에 대해 락을 보유하게 됩니다.

```sql
-- 세션2에서 데이터 수정 시도
set autocommit false;
update member set money=500 where member_id = 'memberA';
```

- **세션2**는 **memberA**의 데이터를 수정하려 하지만, **세션1**이 락을 보유하고 있기 때문에 대기합니다.
- **세션1**이 커밋하거나 트랜잭션이 종료될 때까지 **세션2**는 락을 획득하지 못하고 대기하게 됩니다.

## 정리

조회 시 락을 걸고 싶을 때는 **`SELECT FOR UPDATE`** 구문을 사용하여 조회 시점에 락을 획득할 수 있습니다. 이로 인해 **트랜잭션 종료 전까지 데이터가 다른 트랜잭션에서 변경되지 않도록** 보호할 수 있습니다. 하지만, 데이터베이스마다 락과 트랜잭션의 동작 방식이 다를 수 있으므로, **데이터베이스 메뉴얼**을 참고하여 정확한 동작을 확인하고 사용해야 합니다.

{: .note }
> **`SELECT FOR UPDATE`** 구문으로 락을 걸었어도 일반적인 SELECT문은 조회(commit 전 데이터)가 됩니다.

> **`SELECT FOR UPDATE`** 구문으로 SELECT를 하면 Lock이 필요하여 락이 없으면 대기하게 됩니다. 
 