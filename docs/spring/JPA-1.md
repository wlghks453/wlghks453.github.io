---
layout: default
title: JPA 제목미정
parent: JPA
grand_parent: 스프링

nav_order: 1
---

# 검색영역
{: .no_toc }

## 목차는 여기인 것 같아요.
{: .no_toc .text-delta }

1. TOC
{:toc}

---

# 영속성 컨텍스트

JPA의 가장 중요한 개념인 영속성 컨텍스트에 대해 알아보자.

이를테면

```
em.persist(Object);
```
를 한다고 해서 바로 db에 저장되는 것이 아닌 영속성 컨텍스트라는 곳에 저장이 된다.

트랜잭션 커밋이 되는 순간 영속성 컨텍스트에 있는 것들이 db로 전달이 된다.

이런 내용이다.

## 엔티티의 생명주기

• 비영속 (new/transient)
영속성 컨텍스트와 전혀 관계가 없는 새로운 상태

• 영속 (managed)
영속성 컨텍스트에 관리되는 상태

• 준영속 (detached)
영속성 컨텍스트에 저장되었다가 분리된 상태

• 삭제 (removed)
삭제된 상태

## 영속성 컨텍스트의 이점

• 1차 캐시

```
em.persist(Object);
```

하는 순간 영속성 컨택스트의 1차 캐시에 저장을 함.
FIND 할 때 1차 캐시에 있나 확인 후 있으면 1차 캐시에서 꺼내서 주고 
없으면 DB에서 조회 후 1차 캐시에 저장 후 RETURN 해준다.

• 동일성(identity) 보장

FIND 한 두 객체는 == 비교 시 TRUE가 된다는 말이다!!

• 트랜잭션을 지원하는 쓰기 지연 (transactional write-behind)

JDBC템플릿의 BATCHINSERT 라는 의미이다.  
모아서 한방에 1네트워크로 COMMIT한다.
이후 엔티티매니저는 제거된다.

• 변경 감지(Dirty Checking)

1차 캐시에 저장할 때 스냅샷도 함께 넣는다. 
커밋되기 전 현재 엔티티와 스냅샷의 엔티티를 비교하여 DELETE, UPDATE SQL이 나가게 된다.

• 지연 로딩(Lazy Loading)

## flush

영속성 컨텍스트의 변경내용을 데이터베이스에 반영

영속성 컨텍스트를 플러시하는 방법

• em.flush() - 직접 호출  sql 저장소에 쌓여있는 sql을 날림.  
  ※1차캐시가 지워지지 않는다.

• 트랜잭션 커밋 - 플러시 자동 호출

• JPQL 쿼리 실행 - 플러시 자동 호출

## 준영속

준영속은 영속성 컨텍스트에서 관리되는 대상을 빼버리는 것!!

• 영속 -> 준영속
• 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)
• 영속성 컨텍스트가 제공하는 기능을 사용 못함

준영속 상태로 만드는 방법

```
• em.detach(entity)
특정 엔티티만 준영속 상태로 전환
• em.clear()
영속성 컨텍스트를 완전히 초기화
• em.close()
영속성 컨텍스트를 종료
```
