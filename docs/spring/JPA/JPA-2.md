---
layout: default
title: JPA 제목미정2
parent: JPA
grand_parent: 스프링
nav_order: 2
---

{: .no_toc }

{: .no_toc .text-delta }

1. TOC
{:toc}

---

# 매핑

테이블,  컬럼 매핑은 생략한다.



## MappedBy

• 객체의 두 관계중 하나를 연관관계의 주인으로 지정 
• 연관관계의 주인만이 외래 키를 관리(등록, 수정) 
• 주인이 아닌쪽은 읽기만 가능 
• 주인은 mappedBy 속성 사용X 
• 주인이 아니면 mappedBy 속성으로 주인 지정

[정리] 
외래 키가 있는 있는 곳을 주인으로 정해라 (N:1 관계에서 N을 의미)
 
단방향 매핑만으로도 이미 연관관계 매핑은 완료 (설계 시, N관계에다가 일단 MANY TO ~~ 필요할 때 양방향으로 해도 늦지 않다.) 

## 일대다 

실무에서는 거의 사용하지 않는 설계라고 하십니다.

1 관계인 객체가 외래키를 관리한다는 의미이다. 

외래키는 무조건 N 관계 테이블에 존재하는데 1관계인 객체에서 외래키를 관리하면 SQL이 N 관계쪽으로 한번 더 나가는 상황이 발생한다.

난 1 관계인 놈만 건드렸는데 N관계의 테이블에 SQL이 날라가는 현상 때문에 헷갈릴 수 있다. 

다대일 관계를 지향하자.

## 일대다에서 양방향을 쓰고 싶을 땐?

N 객체에 @JoinColumn(insertable=false, updateable=false) 를 넣어준다. 

읽기전용으로 만들어버린다.

## 상속관계 매핑

데이터베이스를 설계할 때 정규화를 기똥차게 하는 방식과 하나의 테이블에 다 때리박는 방식과 타입별로 테이블을 모두 쪼개는 방식 3가지로 한다고 보면 된다.

정규화 방식이 객체의 상속 방식과 비슷하다고 볼 수 있다. 

타입별로 테이블을 모두 쪼개는 방식은 머리에 두지말자. 나중에 후회할 것이다!!!!
하지만 서브 타입을 명확하게 구분해서 처리할 때 효과적이니 잘 생각해보아야...!!


상속관계 사용법

@Inheritance(strategy=InheritanceType.XXX)  를 부모 엔티티에 적용한다. 아래 3가지 타입 중 1개 전략을 선택한다.
JOINED: 조인 전략
SINGLE_TABLE: 단일 테이블 전략
TABLE_PER_CLASS: 구현 클래스마다 테이블 전략

@DiscriminatorColumn 어노테이션은 부모 테이블에 하위 테이블의 타입을 정의할 때 넣어주면 된다.  DTYPE의 컬럼이 생기고 자식 엔티티명을 기본으로 넣어준다.

@DiscriminatorValue(“XXX”) 자식엔티티에 추가하여 엔티티명으로 타입구분하는 것이 아니고 원하는 타입을 지정할 때 사용함.


## @MappedSuperclass

등록자, 등록일, 수정자, 수정일 같이 공통적으로 사용하는 컬럼들을 정의한다. 

간단하므로 패스

• 테이블과 관계 없고, 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할 
• 주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통으로 적용하는 정보를 모을 때 사용 
• 참고: @Entity 클래스는 엔티티나 @MappedSuperclass로 지정한 클래스만 상속 가능

