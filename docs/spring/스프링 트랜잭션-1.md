---
layout: default
title: 스프링 트랜잭션
parent: 스프링
nav_order: 1
---

# 검색영역
{: .no_toc }

## 목차는 여기인 것 같아요.
{: .no_toc .text-delta }

1. TOC
{:toc}

---

예제 하위카테고리1  영역

## 스프링 트랜잭션 주의사항

@Transactional 애노테이션이 특정 클래스나 메서드에 하나라도 있으면 트랜잭션 AOP는 프록시를 만들어서 스프링 컨테이너에 등록한다. 
그리고 실제 Service 객체 대신에 프록시인Service$$CGLIB`를 스프링 빈에 등록한다. 그리고 프록시는 내부에 실제 Service를 참조하게 된다. 
여기서 핵심은 실제 객체 대신에 프록시가 스프링 컨테이너에 등록되었다는 점이다.

### 내부호출

이미지 넣기는 추후

트랜잭션이 적용되지 않은 메소드 호출 > 해당 메소드에서 트랜잭션이 적용된 메소드 호출 > 트랜잭션 적용X

이유 : 프록시에서 해당메소드를 참조했을 때 트랜잭션 적용이 되지 않는 메소드이기 때문에 트랜잭션 시작을 아예하지 않았다.

이후 트랜잭션이 적용된 메소드를 호출해도 실제 서비스 메소드에서 THIS.Method()를 수행한거나 마찬가지이므로 트랜잭션 적용 되지 않는다.

#### 해결방안

다른 외부 클래스로 옮겨 프록시를 통해 호출되도록 수정한다. (가장 많이 사용)

컴파일 시점, 클래스 로더 시점에 트랜잭션 시작, 종료 코드로 감싸는 방법이 있지만 복잡함.

### public 트랜잭션 적용

트랜잭션은 주로 비즈니스 로직의 시작점에 걸기 때문에 대부분 외부에 열어준 곳을 시작점으로 사용한다. 
이런 이유로 public 메서드에만 트랜잭션을 적용하도록 설정되어 있다.
😎스프링 부트 3.0부터는 protected, default에도 트랜잭션이 적용된다.

### 초기화

초기화하는 중 일때는 트랜잭션이 적용되지 않는다.
@PostConstruct 와 @Transactional 같이 사용하면 트랜잭션이 적용되지 않는다.
왜냐하면 초기화 코드가 먼저 호출되고, 그 다음에 트랜잭션 AOP가 적용되기 때문이다. 
따라서 초기화 시점에는 해당 메서드에서 트랜잭션을 획득할 수 없다

#### 해결방안

스프링 컨테이너가 완벽히 떴을 때 수행한다.

가장 확실한 대안은  ApplicationReadyEvent 이벤트를 사용하는 것이다.

@EventListener(value = ApplicationReadyEvent.class)
@Transactional

### 서브 주제5

The search button displays in the bottom right corner of the screen and triggers the search input when clicked.

```yaml
# Enable or disable the search button that appears in the bottom right corner of every page
# Supports true or false (default)
search.button: true
```

## 스프링 트랜잭션 옵션

스프링 트랜잭션은 다양한 옵션을 제공한다.

### value, transactionManager

트랜잭션을 사용하려면 먼저 스프링 빈에 등록된 어떤 트랜잭션 매니저를 사용할지 알아야 한다. 생각해보면 코드로 직접 트랜잭션을 사용할 때 분명 트랜잭션 매니저를 주입 받아서 사용했다. 
둘 중 하나에 트랜잭션 매니저의 스프링 빈의 이름을 적어주면 된다.
이 값을 생략하면 기본으로 등록된 트랜잭션 매니저를 사용하기 때문에 대부분 생략한다. 그런데 사용하는 트랜잭션 매니저가 둘 이상이라면 다음과 같이 트랜잭션 매니저의 이름을 지정해서 구분하면 된다.

```java
public class TxService {
    @Transactional("memberTxManager")
 public void member() {...}
    @Transactional("orderTxManager")
 public void order() {...}
 }
```
### rollbackFor
예외 발생시 스프링 트랜잭션의 기본 정책은 다음과 같다.

언체크 예외인 RuntimeException, Error와 그 하위 예외가 발생하면 롤백한다.
체크 예외인 Exception과 그 하위 예외들은 커밋한다.

이 옵션을 사용하면 기본 정책에 추가로 어떤 예외가 발생할 때 롤백할 지 지정할 수 있다.

```java
@Transactional(rollbackFor = Exception.class)
```

### noRollbackFor

### propagation

### isolation

트랜잭션 격리 수준을 지정할 수 있다. 기본 값은 데이터베이스에서 설정한 트랜잭션 격리 수준을 사용하는 DEFAULT이다.

## Custom content for search index
{: .d-inline-block }

New (v0.4.0)
{: .label .label-green }

Advanced
{: .label .label-yellow }

By default, the search feature indexes a page's `.content`, `.title`, and *some* headers within the `.content`. Other data (e.g. front matter, files in `_data` and `assets`) is not indexed. Users can customize what is indexed.

{: .warning }
> Customizing search indices is an advanced feature that requires Javascript and Liquid knowledge.

1. When Just the Docs is a local or gem theme, ensure `assets/js/zzzz-search-data.json` is up-to-date with [Generate search index when used as a gem](#generate-search-index-when-used-as-a-gem).
2. Add a new file named `_includes/lunr/custom-data.json`. Insert custom Liquid code that reads your data (e.g. the page object at `include.page`) then generates custom Javascript fields that hold the custom data you want to index. Verify these fields in the generated `assets/js/search-data.json`.
3. Add a new file named `_includes/lunr/custom-index.js`. Insert custom Javascript code that reads your custom Javascript fields and inserts them into the search index. You may want to inspect `assets/js/just-the-docs.js` to better understand the code.

#### Example

This example adds front matter `usage` and `examples` fields to the search index.

`_includes/lunr/custom-data.json` custom code reads the page `usage` and `examples` fields, normalizes the text, and writes the text to custom Javascript `myusage` and `myexamples` fields. Javascript fields are similar yet [not the same as JSON](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON#javascript_and_json_differences). `jsonify` will probably work for most scenarios.

{% raw %}
```liquid
{%- capture newline %}
{% endcapture -%}
"myusage": {{ include.page.usage | markdownify | replace:newline,' ' | strip_html | normalize_whitespace | strip | jsonify }},
"myexamples": {{ include.page.examples | markdownify | replace:newline,' ' | strip_html | normalize_whitespace | strip | jsonify }},
```
{% endraw %}

`_includes/lunr/custom-index.js` custom code is inserted into the Javascript loop of `assets/js/just-the-docs.js`. All custom Javascript fields are accessed as fields of `docs[i]` such as `docs[i].myusage`. Finally, append your custom fields on to the already existing `docs[i].content`.

```javascript
const content_to_merge = [docs[i].content, docs[i].myusage, docs[i].myexamples];
docs[i].content = content_to_merge.join(' ');
```
